/*
1060 爱丁顿数（25 分）
英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。

现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。

输入格式：
输入第一行给出一个正整数 N (≤10
​5
​​ )，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。

输出格式：
在一行中给出 N 天的爱丁顿数。

输入样例：
10
6 7 6 9 3 10 8 2 7 8
输出样例：
6
*/

/*
总结:
大体的思路是，将每次骑车的距离作为数组的下标＋1，然后总结的时候从大到小算过来，如果他们的总次数大于等于下标了
就代表找到爱丁顿数了。
注意，满足E天超过E英里的,也就是说E那个数字本身的次数是不算的。
还有一个点，骑车距离没有设置上限，但是我们知道，再怎么骑多，E的上限取决于最小数，也就是有上限的N(<=100000),
那么对于每个大于100000的数，我将他们统一计算在ch[100001]这个格子，只要从100001开始倒读即可。
*/

#include<iostream>
#include<cstring>

using namespace std;
int ch[100005];
int main(){
#ifdef LOCAL 
    freopen("input.in","r",stdin);
    freopen("output.out","w",stdout);
#endif
    memset(ch,0,sizeof(ch));
    int N; cin >> N;
    for(int i = 0;i < N;i++){
        int temp; cin >> temp;
        if(temp > 100000){ch[100001]++;}
        else{ch[temp]++;}
    }
    int sum = 0;
    for(int i = 100001;i>=0;i--){
        if(sum >= i){cout << i;break;}
        sum += ch[i];
    }
    return 0;
}